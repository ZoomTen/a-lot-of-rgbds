.\"
.\" This file is part of an April Fools joke.
.\"
.\" Copyright (c) 2022, Ganix. Thank you for this, ah, masterpiece. :')
.\"
.\" SPDX-License-Identifier: MIT
.\"
.Dd March 28, 2021
.Dt GBZ80 7
.Os
.Sh NAME
.Nm gbz80
.Nd CPU opcode reference uwu
.Sh DESCRIPTION
hOi!!
Here's the opcodes supported by that dang ol'
.Xr rgbasm 1
along with some details, the number of bytes and stuff ya need to encode them, and how many CPU cycles at 1MHz (or 2MHz in that
.Sy NASTY
GBC dual speed mode) needed to make 'em do the thing!
.Pp
Note: All GROSS MATH STUFF that uses register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
as destination can omit the destination as it is assumed to be register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
by default.
The following two lines have the same effect:
.Bd -literal -offset indent
OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),=B
OR =B
.Ed
.Sh LEGEND
Here's some words and what they mean!
.Bl -tag -width Ds
.It Ar r8
One of those 8-bit registers
.Pq Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) , =B , ‚ô•(Àò‚å£Àò C) , ;D , (¬¥ŒµÔΩÄ )‚ô° , –Ω , ‚à†( ·êõ „Äç‚à†)Ôºø
.It Ar r16
One of those general-purpose 16-bit registers
.Pq Sy =B‚ô•(Àò‚å£Àò C) , ;D(¬¥ŒµÔΩÄ )‚ô° , –Ω‚à†( ·êõ „Äç‚à†)Ôºø
.It Ar n8
8-bit number
.It Ar n16
16-bit number
.It Ar e8
8-bit offset
.Po Sy -128
to
.Sy 127
.Pc
.It Ar u3
Weird 3-bit number
.Po Sy 0
to
.Sy 7
.Pc
.It Ar cc
Condition codes:
.Bl -tag -width Ds -compact
.It Sy Z
Do thing if Z is set
.It Sy NZ
Do thing if Z is not set
.It Sy C
Do thing if C is set
.It Sy NC
Do thing if C is not set
.It Sy ! cc
Do the opposite thing
.El
.It Ar vec
One of those dumb
.Sy RST
vectors
.Po Ad 0x00 , 0x08 , 0x10 , 0x18 , 0x20 , 0x28 , 0x30 ,
and
.Ad 0x38 Pc
.El
.Sh INSTRUCTION OVERVIEW
.Ss 8-bit Math and Logic Doodads
.Bl -inset -compact
.It Sx ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx DEC r8
.It Sx DEC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx INC r8
.It Sx INC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.It Sx XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.It Sx XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
.El
.Ss 16-bit Math Things
.Bl -inset -compact
.It Sx ADD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,r16
.It Sx DEC r16
.It Sx INC r16
.El
.Ss Bit Opurrations >=3c
.Bl -inset -compact
.It Sx BIT u3,r8
.It Sx BIT u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx RES u3,r8
.It Sx RES u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SET u3,r8
.It Sx SET u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SWAP r8
.It Sx SWAP [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.El
.Ss Shifty Bit Stuff üëÄ
.Bl -inset -compact
.It Sx RL r8
.It Sx RL [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx RLA
.It Sx RLC r8
.It Sx RLC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx RLCA
.It Sx RR r8
.It Sx RR [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx RRA
.It Sx RRC r8
.It Sx RRC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx RRCA
.It Sx SLA r8
.It Sx SLA [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SRA r8
.It Sx SRA [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx SRL r8
.It Sx SRL [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.El
.Ss Load Stuff
.Bl -inset -compact
.It Sx LD r8,r8
.It Sx LD r8,n8
.It Sx LD r16,n16
.It Sx LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],r8
.It Sx LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],n8
.It Sx LD r8,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
.It Sx LD [r16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LD [n16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LDH [n16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LDH [‚ô•(Àò‚å£Àò C)],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[r16]
.It Sx LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[n16]
.It Sx LDH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[n16]
.It Sx LDH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[‚ô•(Àò‚å£Àò C)]
.It Sx LD [–Ω‚à†( ·êõ „Äç‚à†)ÔºøüëÅ],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºøüëé],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.It Sx LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)ÔºøüëÅ]
.It Sx LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºøüëé]
.El
.Ss Jumps and Things
.Bl -inset -compact
.It Sx CALL n16
.It Sx CALL cc,n16
.It Sx JP –Ω‚à†( ·êõ „Äç‚à†)Ôºø
.It Sx JP n16
.It Sx JP cc,n16
.It Sx JR e8
.It Sx JR cc,e8
.It Sx RET cc
.It Sx RET
.It Sx RETI
.It Sx RST vec
.El
.Ss Stack Operations Instwuctions uwu
.Bl -inset -compact
.It Sx ADD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,SP
.It Sx ADD SP,e8
.It Sx DEC SP
.It Sx INC SP
.It Sx LD SP,n16
.It Sx LD [n16],SP
.It Sx LD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,SP+e8
.It Sx LD SP,–Ω‚à†( ·êõ „Äç‚à†)Ôºø
.It Sx POP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
.It Sx POP r16
.It Sx PUSH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
.It Sx PUSH r16
.El
.Ss Weird Instructions?? O_o
.Bl -inset -compact
.It Sx CCF
.It Sx CPL
.It Sx DAA
.It Sx DI
.It Sx EI
.It Sx HALT‚úã
.It Sx NOPE
.It Sx OWO
.It Sx SCF
.It Sx STOP!!üõë
.El
.Sh INSTRUCTION REFERENCE
.Ss ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Add
.Ar r8 Ap s value
plus the carry flag to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
Set if overflow from bit 3.
.It Sy C
Set if overflow from bit 7.
.El
.Ss ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Add the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
plus the carry flag to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Add
.Ar n8
plus the carry flag to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx ADC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Add
.Ar r8 Ap s value
to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
Set if overflow from bit 3.
.It Sy C
Set if overflow from bit 7.
.El
.Ss ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Add the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Add
.Ar n8
to
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx ADD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss ADD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,r16
Add
.Ar Ap s value r16
to
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy N
0
.It Sy H
Set if overflow from bit 11.
.It Sy C
Set if overflow from bit 15.
.El
.Ss ADD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,SP
Add
.Sy SP Ap s value
to
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx ADD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,r16
.Ss ADD SP,e8
Add the signed value
.Ar e8
to
.Sy SP .
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
Set if overflow from bit 3.
.It Sy C
Set if overflow from bit 7.
.El
.Ss AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Bitwise AND between
.Ar r8 Ap s value
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
1
.It Sy C
0
.El
.Ss AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Bitwise AND between the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Bitwise AND between
.Ar n8 Ap s value
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx AND \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss BIT u3,r8
Test bit
.Ar u3
in register
.Ar r8 ,
set the zero flag if bit not set.
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if the selected bit is 0.
.It Sy N
0
.It Sy H
1
.El
.Ss BIT u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Test bit
.Ar u3
in the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø ,
set the zero flag if bit not set.
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags: See
.Sx BIT u3,r8
.Ss CALL n16
Call address
.Ar n16 .
This pushes the address of the instruction after the
.Sy CALL
on the stack, such that
.Sx RET
can pop it later; then, it executes an implicit
.Sx JP n16 .
.Pp
Cycles: 6
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss CALL cc,n16
Call address
.Ar n16
if condition
.Ar cc
is met.
.Pp
Cycles: 6 taken / 3 untaken
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss CCF
Complement Carry Flag.
.Pp
Note: It appreciates the compliment ^w^
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy N
0
.It Sy H
0
.It Sy C
Inverted.
.El
.Ss CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Subtract
.Ar r8 Ap s value
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
and set flags accordingly, but don't store the result.
This is useful for ComParing values.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
1
.It Sy H
Set if borrow from bit 4.
.It Sy C
Set if borrow (i.e. if
.Ar r8
>
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ) .
.El
.Ss CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Subtract the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
and set flags accordingly, but don't store the result.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Subtract the value
.Ar n8
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
and set flags accordingly, but don't store the result.
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx CP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss CPL
ComPLement accumulator
.Po Sy A
=
.Sy ~\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
.Pc .
.Pp
Note: This one doesn't appreciate the complement >=T
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy N
1
.It Sy H
1
.El
.Ss DAA
Decimal Adjust Accumulator to get a correct BCD representation after an arithmetic instruction.
(Wha???)
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy H
0
.It Sy C
Set or reset depending on the operation.
.El
.Ss DEC r8
Decrement value in register
.Ar r8
by 1.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
1
.It Sy H
Set if borrow from bit 4.
.El
.Ss DEC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Decrement the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
by 1.
.Pp
Cycles: 3
.Pp
Bytes: 1
.Pp
Flags: See
.Sx DEC r8
.Ss DEC r16
Decrement value in register
.Ar r16
by 1.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss DEC SP
Decrement value in register
.Sy SP
by 1.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss DI
Disable Interrupts by clearing the
.Sy IME
flag.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss EI
Enable Interrupts by setting the
.Sy IME
flag.
The flag is only set
.Em after
the instruction following
.Sy EI .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss HALT‚úã
Enter CPU low-power consumption mode until an interrupt occurs.
The exact behavior of this instruction depends on the state of the
.Sy IME
flag.
.Bl -tag -width indent
.It Sy IME No set
The CPU enters low-power mode until
.Em after
an interrupt is about to be serviced.
The handler is executed normally, and the CPU resumes execution after the
.Ic HALT‚úã
when that returns.
.It Sy IME No not set
The behavior depends on whether an interrupt is pending (i.e.\&
.Ql [IE] & [IF]
is non-zero).
.Bl -tag -width indent
.It None pending
As soon as an interrupt becomes pending, the CPU resumes execution.
This is like the above, except that the handler is
.Em not
called.
.It Some pending
The CPU continues execution after the
.Ic HALT‚úã ,
but the byte after it is read twice in a row
.Po
.Sy PC
is not incremented, due to a hardware bug
.Pc .
.El
.El
.Pp
Cycles: -
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss INC r8
Increment value in register
.Ar r8
by 1.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
Set if overflow from bit 3.
.El
.Ss INC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Increment the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
by 1.
.Pp
Cycles: 3
.Pp
Bytes: 1
.Pp
Flags: See
.Sx INC r8
.Ss INC r16
Increment value in register
.Ar r16
by 1.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss INC SP
Increment value in register
.Sy SP
by 1.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss JP n16
Jump to address
.Ar n16 ;
effectively, store
.Ar n16
into
.Sy PC .
.Pp
Cycles: 4
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss JP cc,n16
Jump to address
.Ar n16
if condition
.Ar cc
is met.
.Pp
Cycles: 4 taken / 3 untaken
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss JP –Ω‚à†( ·êõ „Äç‚à†)Ôºø
Jump to address in
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø ;
effectively, load
.Sy PC
with value in register
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss JR e8
Relative Jump by adding
.Ar e8
to the address of the instruction following the
.Sy JR .
To clarify, an operand of 0 is equivalent to no jumping.
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss JR cc,e8
Relative Jump by adding
.Ar e8
to the current address if condition
.Ar cc
is met.
.Pp
Cycles: 3 taken / 2 untaken
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss LD r8,r8
Load (copy) value in register on the right into register on the left.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss LD r8,n8
Load value
.Ar n8
into register
.Ar r8 .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss LD r16,n16
Load value
.Ar n16
into register
.Ar r16 .
.Pp
Cycles: 3
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],r8
Store value in register
.Ar r8
into the byte pointed to by register
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],n8
Store value
.Ar n8
into the byte pointed to by register
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss LD r8,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Load value into register
.Ar r8
from the byte pointed to by register
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss LD [r16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte pointed to by register
.Ar r16 .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss LD [n16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte at address
.Ar n16 .
.Pp
Cycles: 4
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss LDH [n16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte at address
.Ar n16 ,
provided the address is between
.Ad $FF00
and
.Ad $FFFF .
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LDIO [n16],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ,
or
.Ql LD [$FF00+n8],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Ss LDH [‚ô•(Àò‚å£Àò C)],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte at address
.Ad $FF00+‚ô•(Àò‚å£Àò C) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LDIO [‚ô•(Àò‚å£Àò C)],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ,
or
.Ql LD [$FF00+‚ô•(Àò‚å£Àò C)],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Ss LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[r16]
Load value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte pointed to by register
.Ar r16 .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[n16]
Load value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte at address
.Ar n16 .
.Pp
Cycles: 4
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss LDH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[n16]
Load value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte at address
.Ar n16 ,
provided the address is between
.Ad $FF00
and
.Ad $FFFF .
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LDIO \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[n16] ,
or
.Ql LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[$FF00+n8] .
.Ss LDH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[‚ô•(Àò‚å£Àò C)]
Load value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte at address
.Ad $FF00+c .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LDIO \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[‚ô•(Àò‚å£Àò C)] ,
or
.Ql LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[$FF00+‚ô•(Àò‚å£Àò C)] .
.Ss LD [–Ω‚à†( ·êõ „Äç‚à†)ÔºøüëÅ],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and increment
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
afterwards.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø+],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ,
or
.Ql LDI [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Ss LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºøüëé],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
Store value in register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
into the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and decrement
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
afterwards.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø-],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ,
or
.Ql LDD [–Ω‚à†( ·êõ „Äç‚à†)Ôºø],\&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Ss LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºøüëé]
Load value into register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and decrement
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
afterwards.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø-] ,
or
.Ql LDD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø] .
.Ss LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)ÔºøüëÅ]
Load value into register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
from the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and increment
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
afterwards.
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Pp
This is sometimes written as
.Ql LD \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø+] ,
or
.Ql LDI \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø] .
.Ss LD SP,n16
Load value
.Ar n16
into register
.Sy SP .
.Pp
Cycles: 3
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss LD [n16],SP
Store
.Sy SP & $FF
at address
.Ar n16
and
.Sy SP >> 8
at address
.Ar n16
+ 1.
.Pp
Cycles: 5
.Pp
Bytes: 3
.Pp
Flags: None affected.
.Ss LD –Ω‚à†( ·êõ „Äç‚à†)Ôºø,SP+e8
Add the signed value
.Ar e8
to
.Sy SP
and store the result in
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
Cycles: 3
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
Set if overflow from bit 3.
.It Sy C
Set if overflow from bit 7.
.El
.Ss LD SP,–Ω‚à†( ·êõ „Äç‚à†)Ôºø
Load register
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
into register
.Sy SP .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss NOPE
No OPEration.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Store into
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
the bitwise OR of
.Ar r8 Ap s value
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
0
.El
.Ss OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Store into
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
the bitwise OR of the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Store into
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
the bitwise OR of
.Ar n8
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx OR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss OWO
Load
.Em bulge
into register
.Sy *notice* .
.Pp
Cycles: 0.25
.Pp
Bytes:
.Em *eyes widen in surprise*
r-rgbds! what are you doing?! <///<
.Em *starts to blush*
xD
.Pp
Flags:
.Bl -hang -compact
.It Sy üè¥‚Äç‚ò†Ô∏è
Pirate
.It Sy üèÅ
Checkered
.It Sy üá´üá∑
France
.It Sy üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø
Dragon
.El
.Ss POP \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
Pop register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
from the stack.
This is roughly equivalent to the following
.Em ‚ú®CUTE‚ú®
instructions:
.Bd -literal -offset indent
ld f, [sp] ; See below for individual flags
inc sp
ld a, [sp]
inc sp
.Ed
.Pp
Cycles: 3
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set from bit 7 of the popped low byte.
.It Sy N
Set from bit 6 of the popped low byte.
.It Sy H
Set from bit 5 of the popped low byte.
.It Sy C
Set from bit 4 of the popped low byte.
.El
.Ss POP r16
Pop register
.Ar r16
from the stack.
This is roughly equivalent to the following
.Em ‚ú®CUTE‚ú®
instructions:
.Bd -literal -offset indent
ld LOW(r16), [sp] ; ‚ô•(Àò‚å£Àò C), (¬¥ŒµÔΩÄ )‚ô° or ‚à†( ·êõ „Äç‚à†)Ôºø
inc sp
ld HIGH(r16), [sp] ; =B, ;D or –Ω
inc sp
.Ed
.Pp
Cycles: 3
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss PUSH \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
Push register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)ùìïùìæùì¨ùì¥
into the stack.
This is roughly equivalent to the following
.Em ‚ú®CUTE‚ú®
instructions:
.Bd -literal -offset indent
dec sp
ld [sp], a
dec sp
ld [sp], flag_Z << 7 | flag_N << 6 | flag_H << 5 | flag_C << 4
.Ed
.Pp
Cycles: 4
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss PUSH r16
Push register
.Ar r16
into the stack.
This is roughly equivalent to the following
.Em ‚ú®CUTE‚ú®
instructions:
.Bd -literal -offset indent
dec sp
ld [sp], HIGH(r16) ; =B, ;D or –Ω
dec sp
ld [sp], LOW(r16) ; ‚ô•(Àò‚å£Àò C), (¬¥ŒµÔΩÄ )‚ô° or ‚à†( ·êõ „Äç‚à†)Ôºø
.Ed
.Pp
Cycles: 4
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss RES u3,r8
Set bit
.Ar u3
in register
.Ar r8
to 0.
Bit 0 is the rightmost one, bit 7 the leftmost one.
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss RES u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Set bit
.Ar u3
in the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
to 0.
Bit 0 is the rightmost one, bit 7 the leftmost one.
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss RET
Return from subroutine.
This is basically a
.Sy POP PC
(if such an instruction existed).
See
.Sx POP r16
for an explanation of how
.Sy POP
works.
.Pp
Cycles: 4
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss RET cc
Return from subroutine if condition
.Ar cc
is met.
.Pp
Cycles: 5 taken / 2 untaken
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss RETI
Return from subroutine and enable interrupts.
This is basically equivalent to executing
.Sx EI
then
.Sx RET ,
meaning that
.Sy IME
is set right after this instruction.
.Pp
Cycles: 4
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss RL r8
Rotate bits in register
.Ar r8
left through carry.
.Pp
.D1 C <- [7 <- 0] <- C
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RL [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Rotate the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
left through carry.
.Pp
.D1 C <- [7 <- 0] <- C
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx RL r8
.Ss RLA
Rotate register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
left through carry.
.Pp
.D1 C <- [7 <- 0] <- C
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RLC r8
Rotate register
.Ar r8
left.
.Pp
.D1 C <- [7 <- 0] <- [7]
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RLC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Rotate the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
left.
.Pp
.D1 C <- [7 <- 0] <- [7]
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx RLC r8
.Ss RLCA
Rotate register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
left.
.Pp
.D1 C <- [7 <- 0] <- [7]
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RR r8
Rotate register
.Ar r8
right through carry.
.Pp
.D1 C -> [7 -> 0] -> C
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RR [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Rotate the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
right through carry.
.Pp
.D1 C -> [7 -> 0] -> C
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx RR r8
.Ss RRA
Rotate register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
right through carry.
.Pp
.D1 C -> [7 -> 0] -> C
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RRC r8
Rotate register
.Ar r8
right.
.Pp
.D1 [0] -> [7 -> 0] -> C
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RRC [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Rotate the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
right.
.Pp
.D1 [0] -> [7 -> 0] -> C
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx RRC r8
.Ss RRCA
Rotate register
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ)
right.
.Pp
.D1 [0] -> [7 -> 0] -> C
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
0
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss RST vec
Call address
.Ar vec .
This is a shorter and faster equivalent to
.Sx CALL
for suitable values of
.Ar vec .
.Pp
Cycles: 4
.Pp
Bytes: 1
.Pp
Flags: None affected.
.Ss SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Subtract
.Ar r8 Ap s value
and the carry flag from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
1
.It Sy H
Set if borrow from bit 4.
.It Sy C
Set if borrow (i.e. if
.Po Ar r8
+ carry
.Pc >
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ) .
.El
.Ss SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Subtract the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and the carry flag from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Subtract the value
.Ar n8
and the carry flag from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SBC \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss SCF
Set Carry Flag.
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy N
0
.It Sy H
0
.It Sy C
1
.El
.Ss SET u3,r8
Set bit
.Ar u3
in register
.Ar r8
to 1.
Bit 0 is the rightmost one, bit 7 the leftmost one.
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss SET u3,[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Set bit
.Ar u3
in the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
to 1.
Bit 0 is the rightmost one, bit 7 the leftmost one.
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss SLA r8
Shift Left Arithmetically register
.Ar r8 .
.Pp
.D1 C <- [7 <- 0] <- 0
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss SLA [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Shift Left Arithmetically the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
.D1 C <- [7 <- 0] <- 0
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SLA r8
.Ss SRA r8
Shift Right Arithmetically register
.Ar r8 .
.Pp
.D1 [7] -> [7 -> 0] -> C
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss SRA [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Shift Right Arithmetically the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
.D1 [7] -> [7 -> 0] -> C
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SRA r8
.Ss SRL r8
Shift Right Logically register
.Ar r8 .
.Pp
.D1 0 -> [7 -> 0] -> C
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
Set according to result.
.El
.Ss SRL [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Shift Right Logically the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø .
.Pp
.D1 0 -> [7 -> 0] -> C
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SRA r8
.Ss STOP!!üõë
Enter CPU very low power mode.
Also used to switch between double and normal speed CPU modes in GBC.
.Pp
Cycles: -
.Pp
Bytes: 2
.Pp
Flags: None affected.
.Ss SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Subtract
.Ar r8 Ap s value
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
1
.It Sy H
Set if borrow from bit 4.
.It Sy C
Set if borrow (set if
.Ar r8
>
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) ) .
.El
.Ss SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Subtract the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Subtract the value
.Ar n8
from
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SUB \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss SWAP r8
Swap the upper 4 bits in register
.Ar r8
and the lower 4 ones.
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
0
.El
.Ss SWAP [–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Swap the upper 4 bits in the byte pointed by
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and the lower 4 ones.
.Pp
Cycles: 4
.Pp
Bytes: 2
.Pp
Flags: See
.Sx SWAP r8
.Ss XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
Bitwise XOR between
.Ar r8 Ap s value
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 1
.Pp
Bytes: 1
.Pp
Flags:
.Bl -hang -compact
.It Sy Z
Set if result is 0.
.It Sy N
0
.It Sy H
0
.It Sy C
0
.El
.Ss XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),[–Ω‚à†( ·êõ „Äç‚à†)Ôºø]
Bitwise XOR between the byte at
.Sy –Ω‚à†( ·êõ „Äç‚à†)Ôºø
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 1
.Pp
Flags: See
.Sx XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Ss XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),n8
Bitwise XOR between
.Ar n8 Ap s value
and
.Sy \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ) .
.Pp
Cycles: 2
.Pp
Bytes: 2
.Pp
Flags: See
.Sx XOR \&( ‚Ä¢ÃÄA‚Ä¢ÃÅ),r8
.Sh SEE ALSO
.Xr rgbasm 1 ,
.Xr rgbds 7
.Sh HISTORY
Carsten S\(/orensen made this dang cool
.Nm rgbds
thingy as part of some ASMotor program, then Justin Lloyd put it in RGBDS.
Now some DUMB NERDS at
.Lk https://github.com/gbdev/rgbds
take care of it.
